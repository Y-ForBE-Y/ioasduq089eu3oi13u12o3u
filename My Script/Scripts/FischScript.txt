local WindUI

local SDebug = false

local function DebugLog(Text)
	if SDebug then
		print(Text)
	end
end

local function DebugWarn(Text)
	if SDebug then
		warn(Text)
	end
end

print("Injecting...")
do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    
    if ok then
        WindUI = result
    else 
        WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/gornorestor-ship-it/OosdpospdosoppodsoKAKmsd/refs/heads/main/NewWind.luau"))()
    end
end

print("Loading Icons")

-- */ РЕГИСТРАЦИЯ ВСЕХ ИКОНОК /* --
do
    local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()
    
    -- ДЕБАГ: посмотрим что вообще есть
    --DebugLog("=== ВСЕ НАБОРЫ ICONS ===")
    for setName, iconSet in pairs(NebulaIcons) do
        --DebugLog("Набор:", setName, "Тип:", type(iconSet))
    end
    
    -- 1. РЕГИСТРИРУЕМ ОСНОВНЫЕ НАБОРЫ (таблицы с иконками)
    WindUI.Creator.AddIcons("material", NebulaIcons.Material)
    WindUI.Creator.AddIcons("lucide", NebulaIcons.Lucide) 
    WindUI.Creator.AddIcons("phosphor", NebulaIcons.Phosphor)
    WindUI.Creator.AddIcons("phosphor_filled", NebulaIcons["Phosphor-Filled"])
    WindUI.Creator.AddIcons("sf", NebulaIcons["SF"])
    WindUI.Creator.AddIcons("symbols", NebulaIcons["Symbols"])
    WindUI.Creator.AddIcons("symbols_filled", NebulaIcons["Symbols-Filled"])
    WindUI.Creator.AddIcons("lab", NebulaIcons["Lab"])
    WindUI.Creator.AddIcons("fluency", NebulaIcons.Fluency)
    
    -- 2. РЕГИСТРИРУЕМ NEBULA ICONS (отдельные иконки)
    WindUI.Creator.AddIcons("nebula", NebulaIcons.nebulaIcons)
    
    --DebugLog("✅ Все иконки зарегистрированы!")
end

-- Загружаем и ВЫЗЫВАЕМ функцию
local LoadedConfig = loadstring(game:HttpGet("https://raw.githubusercontent.com/gornorestor-ship-it/OosdpospdosoppodsoKAKmsd/refs/heads/main/KeySys.luau"))()

print("Loading Modules")
-- For Market 
local Rods_Module = loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/InGameModules/Fisch/RodsModule.luau"))()
local Fish_Module = loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/InGameModules/Fisch/FishModule/Fish.lua"))()
local success, Items_Module = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/InGameModules/Fisch/ItemsModule.luau"))()
end)
local Spears_Module = loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/InGameModules/Fisch/SpearsModule.lua"))()


print("Loading Theme")
do
	WindUI:AddTheme({
		Name = "Transparent Theme",
		
		Accent = Color3.fromHex("#30FF6A"),
		Dialog = Color3.fromHex("#000000"),
		Outline = Color3.fromHex("#30FF6A"),
		Text = Color3.fromHex("#FFFFFF"),
		Placeholder = Color3.fromHex("#7a7a7a"),
		Background = Color3.fromHex("#000000"),
		Button = Color3.fromHex("#1a1a1a"),
		Icon = Color3.fromHex("#e7ff2f")
	})

	WindUI:AddTheme({
		Name = "White Blue Theme",
		
		Accent = Color3.fromHex("#00a8ff"),  -- Голубой акцент
		Dialog = Color3.fromHex("#ffffff"),  -- Белый фон
		Outline = Color3.fromHex("#00a8ff"), -- Голубые контуры
		Text = Color3.fromHex("#2c3e50"),    -- Темно-синий текст
		Placeholder = Color3.fromHex("#95a5a6"), -- Серый плейсхолдер
		Background = Color3.fromHex("#ecf0f1"), -- Светло-серый фон
		Button = Color3.fromHex("#3498db"),  -- Синяя кнопка
		Icon = Color3.fromHex("#00a8ff")     -- Голубые иконки
	})

	WindUI:AddTheme({
		Name = "Blue White Gradient Theme",
		
		Accent = Color3.fromHex("#00a8ff"),  -- Яркий голубой
		Dialog = Color3.fromHex("#ffffff"),  -- Белый фон
		Outline = Color3.fromHex("#00a8ff"), -- Голубые контуры
		Text = Color3.fromHex("#2c3e50"),    -- Темно-синий текст для контраста
		Placeholder = Color3.fromHex("#7f8c8d"), -- Серый плейсхолдер
		Background = Color3.fromHex("#e8f4fc"), -- Очень светлый голубой фон
		Button = Color3.fromHex("#00a8ff"),  -- Голубая кнопка
		Icon = Color3.fromHex("#00a8ff")     -- Голубые иконки
	})

	WindUI:AddTheme({
		Name = "Black Background Blue White Theme",
		
		Accent = Color3.fromHex("#00a8ff"),  -- Голубой акцент
		Dialog = Color3.fromHex("#1a1a1a"),  -- Темный фон диалогов
		Outline = Color3.fromHex("#00a8ff"), -- Голубые контуры
		Text = Color3.fromHex("#ffffff"),    -- Белый текст
		Placeholder = Color3.fromHex("#7f8c8d"), -- Серый плейсхолдер
		Background = Color3.fromHex("#000000"), -- Черный фон
		Button = Color3.fromHex("#00a8ff"),  -- Голубая кнопка
		Icon = Color3.fromHex("#00a8ff")     -- Голубые иконки
	})

	WindUI:AddTheme({
		Name = "Black Background Blue White Theme",
		
		Accent = Color3.fromHex("#00a8ff"),  -- Голубой акцент
		Dialog = Color3.fromHex("#0a0a0a"),  -- Темный фон диалогов
		Outline = Color3.fromHex("#00a8ff"), -- Голубые контуры
		Text = Color3.fromHex("#ffffff"),    -- Белый текст
		Placeholder = Color3.fromHex("#7f8c8d"), -- Серый плейсхолдер
		Background = Color3.fromHex("#000000"), -- Черный фон
		Button = Color3.fromHex("#00a8ff"),  -- Голубая кнопка
		Icon = Color3.fromHex("#00a8ff"),    -- Голубые иконки
		
		-- Дополнительные настройки для табов
		Tab = {
			Background = Color3.fromHex("#000000"), -- Черный фон табов
			Text = Color3.fromHex("#ffffff"),       -- Белый текст табов
			Accent = Color3.fromHex("#00a8ff")      -- Голубой акцент табов
		},
		
		Section = {
			Background = Color3.fromHex("#0a0a0a"), -- Темный фон секций
			Text = Color3.fromHex("#ffffff")        -- Белый текст секций
		}
	})
end

print("Loading Main Ui")

-- */  Window  /* --
local Window = WindUI:CreateWindow({
    Title = "Eternal",
    Author = "by HUISOSIKUSITUNITY x Y-ForBE-Y",
    Folder = "Eternal",
    NewElements = true,
    HideSearchBar = false,

    -- Иконка для окна
	Icon = "lucide:orbit",

    -- ↓ This all is Optional. You can remove it.
    Size = UDim2.fromOffset(800, 540),
    --MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(1850, 1260),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    --HideSearchBar = true,
    ScrollBarEnabled = false,
	Debug = SDebug,

    -- Настройки прозрачности основного окна
    BackgroundTransparency = 0.2,
    BackgroundColor = Color3.fromHex("#000000"),
    BlurBackground = true,
    BlurIntensity = 0.7,

    -- Настройки прозрачности для внутренних элементов
    ElementTransparency = {
        Main = 0.1,
        Section = 0.2,
        Button = 0.1,
        Toggle = 0.1,
        Dropdown = 0.2,
        Slider = 0.2,
        Input = 0.2,
        Tab = 0.1  -- Прозрачность табов
    },

    -- Применяем нашу тему
    Theme = "Black Background Blue White Theme",

    -- ↓ Optional. You can remove it.
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function()
            DebugLog("clicked")
        end,
    },

    -- Передаем загруженную конфигурацию
    KeySystem = LoadedConfig,

    OpenButton = {
        Title = "Open eternal",
        CornerRadius = UDim.new(1,0),
        StrokeThickness = 3,
        Enabled = true,
        Draggable = true,
        OnlyMobile = true,
        
        Color = ColorSequence.new(
            Color3.fromHex("#30FF6A"), 
            Color3.fromHex("#e7ff2f")
        )
    }
})

Window:SetToggleKey(Enum.KeyCode.RightControl)

-- */  Tags  /* --
do
    Window:Tag({
        Title = "v" .. "0.0.2", 
        Color = Color3.fromHex("#6b31ff")
    })
end

print("Loading Ui Elements")
	
-- Variables --
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Будем хранить текущие ссылки на персонажа и humanoid
local LCharacter
local LHumanoid

-- Переменные для чекбоксов и циклов
local JumpHeightLoop = nil
local JumpPowerLoop = nil
local WalkSpeedLoop = nil
local TimeLoop = nil

local originalJumpHeight = 7.2
local originalJumpPower = 50
local originalWalkSpeed = 16

-- Функция для обновления ссылок на персонажа
local function updateCharacterReferences(character)
    LCharacter = character
    LHumanoid = character:WaitForChild("Humanoid")
    
    -- Сохраняем оригинальные значения при появлении персонажа
    originalJumpHeight = LHumanoid.JumpHeight
    originalWalkSpeed = LHumanoid.WalkSpeed
    originalJumpPower = LHumanoid.JumpPower
end

-- Functions --
local function SetWalkSpeed(Value)
    if LHumanoid and LHumanoid.Parent then
        LHumanoid.WalkSpeed = Value
    end
end 

local function SetJumpHeight(Value)
    if LHumanoid and LHumanoid.Parent then
        LHumanoid.JumpHeight = Value
    end
end

local function SetJumpPower(Value)
    if LHumanoid and LHumanoid.Parent then
        LHumanoid.JumpPower = Value
    end
end

local function sit_down(Value)
    if LHumanoid and LHumanoid.Parent then
        LHumanoid.Sit = Value
    end
end

local function Suicide()
    if LHumanoid and LHumanoid.Parent then
        LHumanoid.Health = 0
    end
end

local function SuicideV2()
    if LHumanoid and LHumanoid.Parent then
        LHumanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
        LHumanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end

-- Инициализация текущего персонажа
if LocalPlayer.Character then
    updateCharacterReferences(LocalPlayer.Character)
else
    LocalPlayer.CharacterAdded:Wait()
    updateCharacterReferences(LocalPlayer.Character)
end


-- Stats --
local IsUnloaded = false

-- Functions
Window:OnDestroy(function()
    DebugLog("Window Destroyed")
    IsUnloaded = true
    DebugLog(IsUnloaded)
end)

local function GetPlayerRod(OnlyEquped)
    if IsUnloaded then return nil, false end
    
    if not OnlyEquped then
        OnlyEquped = false
    end

    local isEquipped, Rod
    local Backpack = game:GetService('Players').LocalPlayer:FindFirstChild("Backpack")
    local WPlayer = game:GetService('Players').LocalPlayer.Character
    local LocalPlayer = game:GetService('Players').LocalPlayer
    local playerName = LocalPlayer.Name
    local Selected_rod_Name = workspace.PlayerStats[playerName].T[playerName].Stats.rod.Value

    if WPlayer:FindFirstChild(Selected_rod_Name) then
        Rod = WPlayer:FindFirstChild(Selected_rod_Name)
        isEquipped = true
        return Rod, isEquipped
    elseif Backpack and Backpack:FindFirstChild(Selected_rod_Name) and not OnlyEquped then
        Rod = Backpack:FindFirstChild(Selected_rod_Name)
        isEquipped = false
        return Rod, isEquipped
    else
        return nil, false        
    end
end

local function teleportBobberVerticalToZone()
    if IsUnloaded then return false end
    
    local workspace = game:GetService("Workspace")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    
    local LocalPlayer = game:GetService('Players').LocalPlayer
    local playerName = LocalPlayer.Name
    local BobberName = workspace.PlayerStats[playerName].T[playerName].Stats.bobber.Value

    -- Находим поплавок
    local tool = character:FindFirstChildOfClass("Tool")
    if not tool then
        return false
    end

    local CurrentTool = workspace:WaitForChild(player.Name):FindFirstChild(tool.Name)
    if not CurrentTool then
        return false
    end

    local Bobber = CurrentTool:FindFirstChild("bobber")
    if not Bobber then
        return false
    end

    -- Получаем ВСЕ рыболовные зоны для проверки
    local fishingZones = {}
    for _, zone in pairs(workspace:WaitForChild("zones"):WaitForChild("fishing"):GetDescendants()) do
        if zone:IsA("BasePart") then
            table.insert(fishingZones, zone)
        end
    end

    -- Параметры рейкаста - ИГНОРИРУЕМ ВСЕ КРОМЕ РЫБОЛОВНЫХ ЗОН
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = fishingZones

    -- Рейкаст вертикально вниз от текущей позиции поплавка
    local raycastOrigin = Bobber.Position + Vector3.new(0, 5, 0)
    local raycastDirection = Vector3.new(0, -500, 0)
    
    local raycastResult = workspace:Raycast(raycastOrigin, raycastDirection, raycastParams)
    
    if not raycastResult then
        return false
    end

    local hitPosition = raycastResult.Position
    local hitInstance = raycastResult.Instance

    -- Проверяем длину лески
    local ropeConstraint = Bobber:FindFirstChild("RopeConstraint")
    if ropeConstraint then
        local verticalDistance = math.abs(Bobber.Position.Y - hitPosition.Y)
        if ropeConstraint.Length < verticalDistance then
            DebugLog("Длина лески недостаточна для телепортации")
            return false
        end
    end

    -- Телепортируем поплавок на поверхность воды
    local newPosition = Vector3.new(
        Bobber.Position.X,
        hitPosition.Y + 0.5,
        Bobber.Position.Z
    )
    
    Bobber.Position = newPosition

    if Bobber:FindFirstChild(BobberName) then
        Bobber:FindFirstChild(BobberName):Destroy()
    end

    return true
end

local lastCastTime = 0
local castCooldown = 0.95
local isCasting = false

local function GetBober()
    if IsUnloaded then return nil end
    
    local Rod, isEquip = GetPlayerRod()
    if not Rod then
        return nil
    end
    
    local Bober = Rod:FindFirstChild("bobber")
    if Bober then
        return Bober
    else
        return nil
    end
end

local function GetRodValies()
    if IsUnloaded then return nil end
    
    local Rod, isEquip = GetPlayerRod(true)
    if isEquip then
        return Rod.values
    else
        DebugWarn("Удочка не экипирована")
    end
end

local function RodIsCasted()
    if IsUnloaded then return false end
    
    local values = GetRodValies()
    if values ~= nil then
        if values.casted.Value == true then
            return true
        else
            return false
        end
    else
        return true
    end
end

local CastDistance = 0
local function ProcesAutoCast(InInstantReel)
    if IsUnloaded then return end
    
    local Rod, isEquip = GetPlayerRod(true)

    if InInstantReel == nil then
        InInstantReel = false
    end

    if not InInstantReel then
        if tick() - lastCastTime < castCooldown or isCasting then
            return
        end
    end

    if isEquip then
        local Cast = Rod.events.castAsync
        if not RodIsCasted() then
            isCasting = true
            wait(0.2)
            Cast:InvokeServer(CastDistance, 1)
            lastCastTime = tick()
            
            local startTime = tick()
            local timeout = 1
            
            spawn(function()
                while tick() - startTime < timeout do
                    if IsUnloaded then 
                        isCasting = false
                        return 
                    end
                    
                    if RodIsCasted() then
                        DebugLog("Удочка успешно скастована")
                        isCasting = false
                        return
                    end
                    wait(0.05)
                end
                
                if Rod and not IsUnloaded then
                    Rod.events.reset:FireServer()
                end
                isCasting = false
            end)
        else
            if RodIsCasted() and not GetBober() then
                Rod.events.reset:FireServer()
            end
            isCasting = false
        end
    end
end

-- Instant Catch функциональность
local function EquipRud()
    if IsUnloaded then return end
    
    local Rod, isEquip = GetPlayerRod()
    if Rod then
        if not isEquip then
            Rod.Parent = game:GetService('Players').LocalPlayer.Character
        else
            Rod.Parent = game:GetService('Players').LocalPlayer:FindFirstChild("Backpack")
        end
    end
end

local function CenterPlayerBarOnFish()
    local reelGUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("reel")
    if reelGUI then
        local bar = reelGUI:FindFirstChild("bar")
        if bar then
            local fish = bar:FindFirstChild("fish")
            local playerbar = bar:FindFirstChild("playerbar")
            
            if fish and playerbar then
                -- Просто ставим playerbar на позицию рыбы
                playerbar.Position = fish.Position
				local halfPlayerbar = playerbar.Size.X.Scale / 2
                
                -- Если вышли за левый край - фиксим
                if playerbar.Position.X.Scale < 0 + halfPlayerbar then
                    playerbar.Position = UDim2.new(halfPlayerbar, 0, playerbar.Position.Y.Scale, playerbar.Position.Y.Offset)
                end
                
                -- Если вышли за правый край - фиксим
                if playerbar.Position.X.Scale + halfPlayerbar > 1 then
                    playerbar.Position = UDim2.new(1 - halfPlayerbar, 0, playerbar.Position.Y.Scale, playerbar.Position.Y.Offset)
                end
            end
        end
    end
end



-- Добавляем переменные для контроля состояния
local Reelling = false
local ReelTime = 3.15
local hasEventFired = false
local ReelStartTime = 0
local Perfect_Only = false
local AtoCastValue = false

local ReelConnection = nil

local function ProcessReel()
	if IsUnloaded then 
        if ReelConnection then
            ReelConnection:Disconnect()
            ReelConnection = nil
        end
        return 
    end
	
	if ReelConnection then  -- Добавьте эту проверку
        ReelConnection:Disconnect()
    end

	ReelConnection = game:GetService("RunService").Heartbeat:Connect(function()
		local ReelGUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("reel")

		if ReelGUI then
			CenterPlayerBarOnFish()

			-- Если событие уже сработало, выходим
			if hasEventFired then
				return
			end

			-- Если только начали риллинг
			if not Reelling then
				ReelStartTime = time()
				Reelling = true
				DebugLog("Setuping time")
				return
			end

			-- Проверяем, прошло ли достаточно времени
			if time() - ReelStartTime >= ReelTime then
				-- Отправляем событие только один раз
				if not hasEventFired then
					game:GetService("ReplicatedStorage"):FindFirstChild("events"):FindFirstChild("reelfinished"):FireServer(100, Perfect_Only)
					DebugLog("Reel Event Fired")
					hasEventFired = true
					
					-- Ждем 0.5 секунды перед сбросом
					wait(0.5)
					
					-- Сбрасываем состояние для следующего цикла
					Reelling = false
					hasEventFired = false
					DebugLog("Ready for new setup")

					if not IsUnloaded then
						if AtoCastValue == true then
							lastCastTime = tick()
							ProcesAutoCast(true)
						end
					end
				end
			end
		else
			-- Если GUI пропал, сбрасываем состояние
			Reelling = false
			hasEventFired = false
			--print("Reel GUI Not Found")
		end
	end)
end


--[[
local function ProcessReel()
		ReelConnection = game:GetService("Players").LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
			if IsUnloaded then 
                if ReelConnection then
                    ReelConnection:Disconnect()
                    ReelConnection = nil
                end
                return 
            end
            
			if child.Name == "reel" then
				Reelling = true
				
				-- Запускаем отслеживание позиции playerbar
				
				barTracking = game:GetService("RunService").Heartbeat:Connect(function()
					if not child or not child.Parent then
						barTracking:Disconnect()
						return
					end
					CenterPlayerBarOnFish()
				end)
				
				local Rod, isEquip = GetPlayerRod()
				--[[ Coment For Legit 
				if Rod then
					wait(AditionalDelay)

					game:GetService("ReplicatedStorage"):FindFirstChild("events"):FindFirstChild("reelfinished"):FireServer(100, Perfect_Only)

                    -- Останавливаем отслеживание перед завершением
                    if barTracking then
                        barTracking:Disconnect()
                    end

                    if not IsUnloaded then
                        if AtoCastValue == true then
                            lastCastTime = tick()
                            ProcesAutoCast(true)
                        end
                    end
				else
                    if barTracking then
                        barTracking:Disconnect()
                    end
                end
				--))
				
				Reelling = false
			end
		end)
end
]]

local function Reel(state)
    if IsUnloaded then 
        if ReelConnection then
            ReelConnection:Disconnect()
            ReelConnection = nil
        end
        return 
    end
    
	if state == true then
		ProcessReel()
	else
		if ReelConnection then
			ReelConnection:Disconnect()
			ReelConnection = nil
		end

		Reelling = false
	end
end



-- Functions End


-- */  Секции с ПРАВИЛЬНЫМИ иконками  /* --
	--Window:Divider()
		local Main = Window:Section({
			Title = "Main",
			Icon = "nebula:home",  -- ✅ Точно работает
			Opened = true
		})
	Window:Divider()
		local Automatic = Window:Section({
			Title = "Automatic",
			Icon = "phosphor:robot"  -- ✅ Теперь работает
		})
	Window:Divider()
		local Market = Window:Section({
			Title = "Market",
			Icon = "fluency:shopping_cart_stock"  -- ✅ Точно работает
		})
	Window:Divider()
		-- Player - используем user иконки
		local Player = Window:Section({
			Title = "Player", 
			Icon = "lucide:user"  -- ✅ Точно работает
		})
	Window:Divider()
		-- Teleport - используем map-pin иконки
		local Teleport = Window:Section({
			Title = "Teleport",
			Icon = "phosphor:map-pin-area"  -- ✅ Точно есть в phosphor_filled
		})
	Window:Divider()
		local Misc = Window:Section({
			Title = "Misc",
			Icon = "fluency:settings_cog_wheels"  -- Правильное имя для settings
		})
	--[[
	Window:Divider()
		local World = Window:Section({
			Title = "World",
			Icon = "lucide:globe"  -- ✅ Точно работает
		})
	]]
	Window:Divider()
		local AppearanceAndConfigs = Window:Section({
			Title = "Appearance & Configs",
			Icon = "arrow-left-right"
		})
	Window:Divider()
		local Development = Window:Section({
			Title = "Development",
			Icon = "lucide:code"  -- ✅ Точно работает
		})
	--Window:Divider()
------------------------------------------------------------------------


-- Main 
do
	do
		local fishingTab = Main:Tab({
			Title = "fishing",
			Icon = "phosphor_filled:fish-simple"
		})
		fishingTab:Select() -- Select Tab

		-- Base Section
		local Base = fishingTab:Section({
			Title = "  Base"	
		})

		local lastUnequipTime = os.time()
		local EQUIP_COOLDOWN = 3
		local wasEquipped = false

		local function UnEquipAllTool()
			local character = game.Players.LocalPlayer.Character
			if character then
				for _, tool in pairs(character:GetChildren()) do
					if tool:IsA("Tool") then
						DebugLog("Tool найден:", tool.Name)
						tool.Parent = game:GetService("Players").LocalPlayer.Backpack
					end
				end
			end
		end

		local function ProccesAutoEquipRod()
			local Rod, isEquip = GetPlayerRod()
			
			if wasEquipped and not isEquip then
				lastUnequipTime = os.time()
				DebugLog("Удочка убрана, таймер обновлен")
			end
			
			wasEquipped = isEquip
			
			if os.time() - lastUnequipTime < EQUIP_COOLDOWN then
				return
			end
			
			local character = game.Players.LocalPlayer.Character

			if not character:FindFirstChild("Nuke") then
				if not character:FindFirstChild(Rod.Name) then
					local Rod_in_Backpack = game:GetService("Players").LocalPlayer.Backpack:FindFirstChild(Rod.Name)
					if Rod_in_Backpack then
						UnEquipAllTool()
					end
				end

				if not isEquip then
					DebugLog("Удочка экипирована")
					Rod.Parent = game:GetService('Players').LocalPlayer.Character
				end
			else
				DebugLog("У Игрока в руках нюк свапнуть нельзя")
			end
		end

		-- Чекбокс для AutoEquipRod
		local AutoEquipRodLoop = nil
		local AutoEquipRodToggle = fishingTab:Toggle({
			Title = "Auto Equip Rod", 
			Default = false,
			Callback = function(state)
				if state == true then
					AutoEquipRodLoop = RunService.Heartbeat:Connect(function()
						-- Проверка на выгрузку скрипта
						if IsUnloaded then 
							if AutoEquipRodLoop then
								AutoEquipRodLoop:Disconnect()
								AutoEquipRodLoop = nil
							end
							return
						end
						
						ProccesAutoEquipRod()
					end)
				else
					if AutoEquipRodLoop then
						AutoEquipRodLoop:Disconnect()
						AutoEquipRodLoop = nil
					end
				end
			end
		})
	


		-- Слайдер дистанции каста
		local AutoEquipDelay = fishingTab:Slider({
			Title = "Auto Equip Delay",
			Step = 0.1,
			Value = {
				Min = 0,
				Max = 10,
				Default = EQUIP_COOLDOWN,
			},
			Callback = function(value) 
				EQUIP_COOLDOWN = tonumber(value)
			end
		})
	
		-- Fishing Section
		local Fishing = fishingTab:Section({
			Title = "  Fishing"
		})

		-- Чекбокс для AutoCast
		local AutoCatsLoop = nil
		local AutoCastToggle
		AutoCastToggle = fishingTab:Toggle({
			Title = "AutoCast", 
			Default = false,
			Callback = function(state)
				AtoCastValue = state
				if state == true then
					AutoCatsLoop = RunService.Heartbeat:Connect(function()
						ProcesAutoCast()
					end)
				else
					if AutoCatsLoop then
						AutoCatsLoop:Disconnect()
					end
				end
			end
		})

		-- Слайдер дистанции каста
		local CastDistanceSlider = fishingTab:Slider({
			Title = "Cast Distance",
			Step = 1,
			Value = {
				Min = 0,
				Max = 99,
				Default = CastDistance,
			},
			Callback = function(value) 
				CastDistance = tonumber(value)
			end
		})

		-- Чекбокс для PerfectOnly
		local PerfectOnlyToggle = fishingTab:Toggle({
			Title = "PerfectOnly", 
			Default = Perfect_Only,
			Callback = function(state)
				Perfect_Only = state
			end
		})

		-- Чекбокс для InstantCatch
		local InstantCatchToggle = fishingTab:Toggle({
			Title = "InstantCatch", 
			Default = false,
			Callback = function(state)
				Reel(state)
			end
		})

		-- Чекбокс для InstantBobber
		local InstantBobberLoop = nil
		local InstantBobberToggle = fishingTab:Toggle({
			Title = "InstantBobber", 
			Default = false,
			Callback = function(state)
				if state == true then
					InstantBobberLoop = RunService.Heartbeat:Connect(function()
						teleportBobberVerticalToZone()
					end)
				else
					if InstantBobberLoop then
						InstantBobberLoop:Disconnect()
					end
				end
			end
		})

	end

	do
		local EventsTab = Main:Tab({
			Title = "Events",
			Icon = "phosphor:gift"
		})

		-- FISCHFRIGHT Section
		local FischFright = EventsTab:Section({
			Title = "FISCHFRIGHT"
		})

		EventsTab:Button({
			Title = "Load Trick or Treat Script",
			Description = 'After loading, a script will start for farming candies in the FISCH FRIGHT event',
			Callback = function()
				loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/Scripts/TestScripts/Trick%20of%20treat.lua"))()
			end
		})
	end


    local Aditionals = Main:Tab({
        Title = "Aditionals",
        Icon = "lucide:puzzle"
    })

--[[
    local Optional = Main:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })
]]
end











-- Misc 
do
	-- BaseTab
	do
		local BaseTab = Misc:Tab({
			Title = "Base",
			Icon = "lucide:layers"
		})
	
		do
			local DisableOxigenSwim
			DisableOxigenSwim = BaseTab:Toggle({
				Title = "DisableOxigenSwim",
				--Desc = "Toggle Description",
				Value = false, -- default value
				Callback = function(state) 
					game.Players.LocalPlayer.Character.Resources.oxygen.Enabled = not state
				end
			})
			local DisableOxigenPeaks
			DisableOxigenPeaks = BaseTab:Toggle({
				Title = "DisableOxigenPeaks",
				--Desc = "Toggle Description",
				Value = false, -- default value
				Callback = function(state) 
					game.Players.LocalPlayer.Character.Resources["oxygen(peaks)"].Enabled = not state
				end
			})
			local DisableOxigenRefactor
			DisableOxigenRefactor = BaseTab:Toggle({
				Title = "DisableOxigenRefactor",
				--Desc = "Toggle Description",
				Value = false, -- default value
				Callback = function(state) 
					game.Players.LocalPlayer.Character.Resources.oxygenRefactor_WIP.Enabled = not state
				end
			})
			local DisableTemperaturePeaks
			DisableTemperaturePeaks = BaseTab:Toggle({
				Title = "DisableTemperaturePeaks",
				--Desc = "Toggle Description",
				Value = false, -- default value
				Callback = function(state) 
					game.Players.LocalPlayer.Character.Resources.temperature.Enabled = not state
				end
			})
			local DisableTemperatureHeat
			DisableTemperatureHeat = BaseTab:Toggle({
				Title = "DisableTemperatureHeat",
				--Desc = "Toggle Description",
				Value = false, -- default value
				Callback = function(state) 
					game.Players.LocalPlayer.Character.Resources["temperature(heat)"].Enabled = not state
				end
			})
		end
	end


	-- Bypass
	do
	
		local Bypass = Misc:Tab({
			Title = "Bypass",
			Icon = "lucide:shield-off"
		})
	
		local XyzClone = nil
		local BypassGpsLoop = nil

		local GetPosition = rawget(_G, "GetPosition") or function()
			local char = Players.LocalPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local p = char.HumanoidRootPart.Position
				return {p.X, p.Y, p.Z}
			end
			return {0,0,0}
		end

		local ExportValue = rawget(_G, "ExportValue") or function(v)
			return tostring(math.floor(tonumber(v) or 0))
		end

		local function GPSSpoof(state)
			if state then
				if XyzClone then return end

				XyzClone = ReplicatedStorage.resources.items.items.GPS.GPS.gpsMain.xyz:Clone()

				local container = Players.LocalPlayer.PlayerGui.backpack.hotbar.Folder.Frame
				XyzClone.Parent = container

				local Pos = GetPosition()
				local StringInput = string.format("%s, %s, %s", ExportValue(Pos[1]), ExportValue(Pos[2]), ExportValue(Pos[3]))
				XyzClone.Text = "<font color='#ff4949'>X</font><font color = '#a3ff81'>Y</font><font color = '#626aff'>Z</font>: "..StringInput

				BypassGpsLoop = RunService.Heartbeat:Connect(function()
					if IsUnloaded then 
						if BypassGpsLoop then
							BypassGpsLoop:Disconnect()
						end
						if XyzClone then
							XyzClone:Destroy()
							XyzClone = nil
						end
						return
					end
					local Pos = GetPosition()
					local StringInput = string.format("%s, %s, %s", ExportValue(Pos[1]), ExportValue(Pos[2]), ExportValue(Pos[3]))
					XyzClone.Text = "<font color='#ff4949'>X</font><font color = '#a3ff81'>Y</font><font color = '#626aff'>Z</font>: "..StringInput
				end)
			else
				if XyzClone then
					XyzClone:Destroy()
					XyzClone = nil
				end
				if BypassGpsLoop then
					BypassGpsLoop:Disconnect()
					BypassGpsLoop = nil
				end
			end
		end

		local BypassGps
		BypassGps = Bypass:Toggle({
			Title = "Bypass GPS",
			--Desc = "Toggle Description",
			Value = false, -- default value
			Callback = function(state)
				if state == true then
					GPSSpoof(true)
				else
					GPSSpoof(false)
				end
			end
		})

		local function RadarSpoof(state)
			-- Включаем все теги радара
			for _, v in pairs(game:GetService("CollectionService"):GetTagged("radarTag")) do
				if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
					v.Enabled = state
				end
			end
			for _, v in pairs(game:GetService("CollectionService"):GetTagged("radarTagWithTimer")) do
				if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
					v.Enabled = state
				end
			end
		end

		local BaypassRadarDistanceLoop = nil
		local EnableBaypassRadar
		EnableBaypassRadar = Bypass:Toggle({
			Title = "Enable Baypas Radar",
			--Desc = "Toggle Description",
			Value = false, -- default value
			Callback = function(state)
				RadarSpoof(state)
			end
		})


		local CustomDistValue
		local CustomRadarDistance = Bypass:Slider({
			Title = "Custom Distance",
			Desc = "Set custom Radar Distance",
			Step = 1,
			Value = {
				Min = 0,
				Max = 9999,
				Default = 9999,
			},
			Callback = function(value) 
				CustomDistValue = tonumber(value)
			end
		})


		local DistSoofEnable = false
		local OriginalValue = {}

		-- Функция для сохранения оригинальных дистанций ВСЕХ радаров
		local function SaveOriginalDistances()
			OriginalValue = {} -- Очищаем таблицу
			for _, zone in pairs(workspace.zones.fishing:GetChildren()) do
				for _, radarName in ipairs({"radar1", "radar2"}) do
					local radar = zone:FindFirstChild(radarName)
					if radar and radar:IsA("BillboardGui") then
						-- Сохраняем оригинальное значение дистанции
						OriginalValue[radar] = radar.MaxDistance
					end
				end
			end
		end

		-- Функция для восстановления оригинальных дистанций ВСЕХ радаров
		local function RestoreOriginalDistances()
			for radar, originalMaxDistance in pairs(OriginalValue) do
				if radar and radar.Parent then
					radar.MaxDistance = originalMaxDistance
				end
			end
			-- Также восстанавливаем все текущие радары на случай если какие-то пропущены
			for _, zone in pairs(workspace.zones.fishing:GetChildren()) do
				for _, radarName in ipairs({"radar1", "radar2"}) do
					local radar = zone:FindFirstChild(radarName)
					if radar and radar:IsA("BillboardGui") and not OriginalValue[radar] then
						radar.MaxDistance = 250 -- Стандартное значение по умолчанию
					end
				end
			end
		end

		local function ChangeRadarDist(Value)
			if DistSoofEnable == false then
				-- Сохраняем оригинальные значения при первом включении
				SaveOriginalDistances()
				DistSoofEnable = true
			end
			
			-- Устанавливаем новое значение для всех радаров
			for _, zone in pairs(workspace.zones.fishing:GetChildren()) do
				for _, radarName in ipairs({"radar1", "radar2"}) do
					local radar = zone:FindFirstChild(radarName)
					if radar and radar:IsA("BillboardGui") then
						--DebugLog(Value, type(Value))
						if not Value or Value == nil or type(Value) ~= "number" then
							Value = 9999
						end
						radar.MaxDistance = Value
					end
				end
			end
		end

		local BaypassRadarDistanceLoop = nil
		local BaypassRadarDistance
		BaypassRadarDistance = Bypass:Toggle({
			Title = "Baypas Radar Distance",
			--Desc = "Toggle Description",
			Value = false, -- default value
			Callback = function(state)
				if state == true then
					-- Сразу сохраняем оригинальные дистанции при включении
					SaveOriginalDistances()
					
					BaypassRadarDistanceLoop = RunService.Heartbeat:Connect(function()
						if IsUnloaded then 
							if BaypassRadarDistanceLoop then
								BaypassRadarDistanceLoop:Disconnect()
							end
							RestoreOriginalDistances() -- Восстанавливаем при выгрузке
							return
						end
						--DebugLog(CustomRadarDistance.Value, type(CustomRadarDistance))
						ChangeRadarDist(CustomDistValue)
					end)
				else
					if BaypassRadarDistanceLoop then
						BaypassRadarDistanceLoop:Disconnect()
					end
					DistSoofEnable = false
					RestoreOriginalDistances()
					OriginalValue = {}
				end
			end
		})



		local SizeSoofEnable = false
		local OriginalSizeValue = {}
		local MIN_DISTANCE = 500   -- Дистанция, внутри которой размер всегда дефолтный
		local MAX_DISTANCE = 3500  -- Дистанция, за которой размер увеличивается в 5 раз
		local MAX_MULTIPLIER = 10   -- Максимальный множитель

		-- Функция для сохранения оригинальных размеров ВСЕХ радаров
		local function SaveOriginalSizes()
			OriginalSizeValue = {}
			for _, zone in pairs(workspace.zones.fishing:GetChildren()) do
				for _, radarName in ipairs({"radar1", "radar2"}) do
					local radar = zone:FindFirstChild(radarName)
					if radar and radar:IsA("BillboardGui") then
						-- Сохраняем индивидуальные размеры каждого радара
						OriginalSizeValue[radar] = {
							Size = radar.Size,
							SizeOffset = radar.SizeOffset
						}
					end
				end
			end
		end

		-- Функция для восстановления оригинальных размеров ВСЕХ радаров
		local function RestoreOriginalSizes()
			for radar, originalData in pairs(OriginalSizeValue) do
				if radar and radar.Parent then
					-- Восстанавливаем индивидуальные размеры каждого радара
					radar.Size = originalData.Size
					radar.SizeOffset = originalData.SizeOffset
				end
			end
		end

		local function GetDistanceFromPlayer(position)
			local player = Players.LocalPlayer
			if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
				return math.huge
			end
			
			local playerPosition = player.Character.HumanoidRootPart.Position
			return (position - playerPosition).Magnitude
		end

		local function CalculateSizeMultiplier(distance)
			if distance <= MIN_DISTANCE then
				return 1  -- Дефолтный размер вблизи
			elseif distance >= MAX_DISTANCE then
				return MAX_MULTIPLIER  -- Максимальный множитель на большой дистанции
			else
				-- Плавное изменение множителя от 1 до MAX_MULTIPLIER
				local normalizedDistance = (distance - MIN_DISTANCE) / (MAX_DISTANCE - MIN_DISTANCE)
				return 1 + (MAX_MULTIPLIER - 1) * normalizedDistance
			end
		end

		local function UpdateRadarSizes()
			if SizeSoofEnable == false then
				SaveOriginalSizes()
				SizeSoofEnable = true
			end
			
			-- Обновляем размеры всех радаров на основе их индивидуальных оригинальных размеров
			for radar, originalData in pairs(OriginalSizeValue) do
				if radar and radar.Parent then
					local zone = radar.Parent
					local distance = GetDistanceFromPlayer(zone.Position)
					local multiplier = CalculateSizeMultiplier(distance)
					
					-- Применяем множитель к индивидуальному оригинальному размеру
					local originalSize = originalData.Size
					local newX = originalSize.X.Scale * multiplier
					local newY = originalSize.Y.Scale * multiplier
					
					radar.Size = UDim2.new(newX, originalSize.X.Offset * multiplier, newY, originalSize.Y.Offset * multiplier)
					radar.SizeOffset = Vector2.new(0, 0)
				end
			end
		end

		local BaypassRadarSizeLoop = nil
		local NormolizeRadarBilbordSize
		NormolizeRadarBilbordSize = Bypass:Toggle({
			Title = "Normolize Radar Bilbord Size",
			--Desc = "Toggle Description",
			Value = false, -- default value
			Callback = function(state)
				NormolizeRadarBilbordSizeValue = state
				if state == true then
					SaveOriginalSizes()
					
					BaypassRadarSizeLoop = RunService.Heartbeat:Connect(function()
						if IsUnloaded then 
							if BaypassRadarSizeLoop then
								BaypassRadarSizeLoop:Disconnect()
							end
							RestoreOriginalSizes()
							return
						end
						UpdateRadarSizes()
					end)
				else
					if BaypassRadarSizeLoop then
						BaypassRadarSizeLoop:Disconnect()
					end
					SizeSoofEnable = false
					RestoreOriginalSizes()
					OriginalSizeValue = {}
				end
			end
		})
	end



	-- Game_Aditionals
	do
		local Game_Aditionals = Misc:Tab({
			Title = "Game Aditionals",
			Icon = "lucide:dices"
		})

		local Misc = Game_Aditionals:Section({
			Title = " Misc",
			Opened = false,
		})

		do
			Game_Aditionals:Button({
				Title = "Discover all location",
				Desc = "", --Make your character sit",
				Callback = function()
					for k, v in pairs(workspace.zones.player:GetChildren()) do
						DebugLog(v.Name)
						game:GetService("ReplicatedStorage").events.discoverlocation:FireServer(v.Name)
					end
				end
			})
		end

		do
			Game_Aditionals:Button({
				Title = "Activate all promocodes",
				--Desc = "", --Make your character sit",
				Callback = function()
					local function ActivetePromo() 
						local argsList = loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/Fisch/promo"))()
						for _, args in ipairs(argsList) do
							game:GetService("ReplicatedStorage"):WaitForChild("events"):WaitForChild("runcode"):FireServer(unpack(args))
							DebugLog(tostring(unpack(args)))
						end
					end
					ActivetePromo() 
				end
			})
		end

		do
			-- Чекбокс для AntiAFKTeg
			local AntiAFKTegLoop = nil
			local Start = 0
			local AntiAFKTeg = Game_Aditionals:Toggle(
				{
					Title = "AntiAFKTeg",
					Value = false,
					Callback = function(state)

						if state == true then
							AntiAFKTegLoop = RunService.Heartbeat:Connect(function()
								if IsUnloaded then
									AntiAFKTegLoop:Disconnect()
									return
								end
								if time() - Start < 1 then
									return
								end
								if game.Players.LocalPlayer.Character:FindFirstChild("afk") then
									Start = time()
									game:GetService("ReplicatedStorage").events.afk:FireServer(false)
								end
							end)
						else
							if AntiAFKTegLoop then
								AntiAFKTegLoop:Disconnect()
							end
						end

					end
				}
			)
		end
	end

	-- Guis
	do
		local Guis = Misc:Tab({
			Title = "Guis",
			Icon = "lucide:layout-template" 
		})

		do
			local Main = Guis:Section({
				Title = "Main",
				Opened = false,
			})
		
			Guis:Button({
				Title = "Black Market",
				Desc = "Opening BlackMarket GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.BlackMarket.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.BlackMarket.Visible
				end
			})

			Guis:Button({
				Title = "Daily shop",
				Desc = "Opening Daily shop GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.DailyShop.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.DailyShop.Visible
				end
			})


			Guis:Button({
				Title = "Challanges",
				Desc = "Opening Challanges GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.Challenges.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.Challenges.Visible
				end
			})

			Guis:Button({
				Title = "FriendQuests",
				Desc = "Opening FriendQuests GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.Friends.FriendQuests.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.Friends.FriendQuests.Visible
				end
			})

			Guis:Button({
				Title = "Aquarium",
				Desc = "Opening Aquarium GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.PersonalAquarium.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.PersonalAquarium.Visible
				end
			})
		end

		do
			local IDK = Guis:Section({
				Title = "IDK",
				Opened = false,
			})

			Guis:Button({
				Title = "Spear Crafting",
				Desc = "Opening Spear Craft GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.SpearCrafting.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.SpearCrafting.Visible
				end
			})
		end

		do
			local Paid = Guis:Section({
				Title = "Paid",
				Opened = false,
			})

			Guis:Button({
				Title = "Boat PopUP",
				Desc = "Opening Boat PopUP GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.BoatPopup.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.BoatPopup.Visible
				end
			})

			Guis:Button({
				Title = "Starter pack",
				Desc = "Opening Starter Pack buying GUI",
				Callback = function()
					game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.starterpack.Visible = not game:GetService("Players").LocalPlayer.PlayerGui.hud.safezone.starterpack.Visible
				end
			})
		end
	end

	-- Server
	do
		local Server = Misc:Tab({
			Title = "Server",
			Icon = "lucide:cloud"
		})

		local Server_Hop = Server:Section({
			Title = " Server Settings",
			Opened = false,
		})

		--Srver Svith Code
		do
			local AutoReloadScript = Server:Toggle({
				Title = "Re Load Script After Chenge Server",
				Desc = "Automatically reload the script after changing the server or place",
				Icon = "lucide:repeat",
				--Type = "Checkbox",
				Value = false, -- default value
				Callback = function(enable) 
					if enable then
						DebugLog("Авто Перезагрузка серипта Включена")
						queue_on_teleport([[
							loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/New"))()
						]])
						--DebugLog("✅ Автозагрузка скрипта включена")
					else
						DebugLog("Авто Перезагрузка серипта Выключена")
						queue_on_teleport("")
						--DebugLog("❌ Автозагрузка скрипта выключена")
					end
				end
			})
		
			do
				-- Функции для сервер хопа
				local function getServers()
					local servers = {}
					local success, result = pcall(function()
						return game:GetService("HttpService"):JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"))
					end)
					
					if success and result and result.data then
						for _, server in pairs(result.data) do
							if server.playing < server.maxPlayers and server.id ~= JobId then
								table.insert(servers, server)
							end
						end
					end
					return servers
				end

				local function serverHop()
					local servers = getServers()
					if #servers > 0 then
						local randomServer = servers[math.random(1, #servers)]
						TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, game:GetService("Players").LocalPlayer)
					else
						WindUI:Notify({
							Title = "Notification Title",
							Content = "No available servers found!",
							Duration = 5,
							--Icon = "bird",
						})
					end
				end

				local Server_Hop_BTN
				Server_Hop_BTN = Server:Button({
					Title = "Server Hop",
					Desc = "Join a different server",
					Locked = false,
					Callback = function()
						Server_Hop_BTN:Highlight()
						serverHop()
					end
				})
			end

			do
				local function rejoin()
					TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
				end

				local Rejoin_BTN
				Rejoin_BTN = Server:Button({
					Title = "Rejoin Server",
					Desc = "Rejoin current server",
					Locked = false,
					Callback = function()
						Rejoin_BTN:Highlight()
						rejoin()
					end
				})
			end
		end

		do
			local Server_Info = Server:Paragraph({
				Title = "Current Server Info",
				Desc = "Place ID: " .. game.PlaceId .. "\nJob ID: " .. game.JobId .. "\nPlayers: " .. #Players:GetPlayers(),
				Locked = true
			})

			Window:OnOpen(function()
				if Server_Info then
					Server_Info:SetDesc("Place ID: " .. game.PlaceId .. "\nJob ID: " .. game.JobId .. "\nPlayers: " .. #Players:GetPlayers())
				end
			end)

			do
				local resetTimer
				local lastClickTime = 0
				local jobButton
				jobButton = Server:Button({
					Title = "		Copy JobID",
					Desc = "Copy current server ID",
					Icon = "lucide:copy",
					Justify = "Center",
					Callback = function() 
						setclipboard(game.JobId)
						jobButton:Highlight()
						jobButton:SetTitle("Copied!")
						jobButton:Highlight()

						lastClickTime = tick()

						if resetTimer then resetTimer:Disconnect() end
						
						resetTimer = game:GetService("RunService").Heartbeat:Connect(function()
							if tick() - lastClickTime >= 1.5 then
								resetTimer:Disconnect()
								resetTimer = nil
								jobButton:SetTitle("Copy JobID")
							end
						end)
					end
				})
			end

			do
				local resetTimer
				local lastClickTime = 0
				local placeButton
				placeButton = Server:Button({
					Title = "   Copy Place ID",
					Desc = "Copy current place id",
					Icon = "lucide:copy",
					Justify = "Center",
					Callback = function()
						setclipboard(game.PlaceId)
						DebugLog("Place ID скопирован!")
						placeButton:SetTitle("Copied!")
						placeButton:Highlight()
						
						lastClickTime = tick()

						if resetTimer then resetTimer:Disconnect() end
						
						resetTimer = game:GetService("RunService").Heartbeat:Connect(function()
							if tick() - lastClickTime >= 1.5 then
								resetTimer:Disconnect()
								resetTimer = nil
								placeButton:SetTitle("Copy Place ID")
							end
						end)
					end
				})
			end
		end
	end

	--[[
		local Optional = Misc:Tab({
			Title = "Optional",
			Icon = "lucide:list"
		})
	]]
end




















-- Automatic 
do

	-- Main
	do
		local Main = Automatic:Tab({
			Title = "Main",
			Icon = "refresh-cw"
		})

		do
		--[[
		local Enchanting = Tabs.Automatic:AddSection("Enchanting", nil)
			Tabs.Automatic:AddButton({
				Title = "Enchant Rod",
				Callback = function()
					Window:Dialog({
						Title = "Are you sure?",
						Content = "After agreeing, the lucky one will be re-enchanted (for this to work, you need to take the relic you need)",
						Buttons = {
							{
								Title = "Confirm",
								Callback = function()
									game:GetService("ReplicatedStorage").events.enchantrod:InvokeServer()
								end
							},
							{
								Title = "Cancel",
								Callback = function()
									DebugLog("Cancelled")
								end
							}
						}
					})
				end
			})
		]]

			local SMain = Main:Section({ Title = "  Main", })

			local function ActivateAllTool()
				local character = game.Players.LocalPlayer.Character
				if character then
					for _, tool in pairs(character:GetChildren()) do
						if tool:IsA("Tool") then
							DebugLog("Tool найден:", tool.Name)
							
							-- Запускаем спам активацией
							coroutine.wrap(function()
								while tool and tool.Parent == character do
									tool:Activate()
									task.wait(0)
								end
								DebugLog("Активация остановлена для:", tool.Name)
							end)()
						end
					end
				end
			end

			local Open_Holdet_Create = Main:Button({
				Title = "Open Holdet Create",
				Desc = "It will spam any selected item that you pick up.",
				Callback = function()
					ActivateAllTool()
				end
			})


			local SSell = Main:Section({ Title = "  Sell", })

			local oldCount = #game:GetService("Players").LocalPlayer.Backpack:GetChildren()
			local isSelling = false
			local lastSaleTime = 0
			local saleCooldown = 1

			--[[
				-- Функция для поиска ТОЛЬКО нашего клона
				function findMerchant()
					-- Используем ТОЛЬКО нашего клона
					if merchantClone and merchantClone.Parent then
						return merchantClone
					else
						return nil
					end
				end
			]]

			local NewMwthod = true

			local function SellALL()
				if NewMwthod == false then
					local success, errorMsg = pcall(function()
						local remote = game:GetService("ReplicatedStorage").events.SellAll
						remote:InvokeServer({
							["npc"] = targetMerchant,
							["idle"] = targetMerchant.description.idle,
							["voice"] = 12
						})
						DebugLog("Продажа выполнена у клона мерчанта")
					end)

					if not success then
						DebugLog("Ошибка при продаже: " .. tostring(errorMsg))
					end
				else
					--SELL ALL NEW
					local remote = game:GetService("ReplicatedStorage").events.SellAll
					local arguments = {}
					local results = remote:InvokeServer(unpack(arguments))
				end
			end

			local function SellOne()
				if NewMwthod == false then
					local success, errorMsg = pcall(function()
						local remote = game:GetService("ReplicatedStorage").events.Sell
						remote:InvokeServer({
							["npc"] = targetMerchant,
							["idle"] = targetMerchant.description.idle,
							["voice"] = 12
						})
						DebugLog("Продажа выполнена у клона мерчанта")
					end)

					if not success then
						DebugLog("Ошибка при продаже: " .. tostring(errorMsg))
					end
				else
					local remote = game:GetService("ReplicatedStorage").events.Sell
					local arguments = {}
					local results = remote:InvokeServer(unpack(arguments))
				end
			end

			-- Функция продажи
			function processAutoSell()
				if isSelling then return end
				
				local currentTime = tick()
				if currentTime - lastSaleTime < saleCooldown then
					return
				end
				
				if not Reelling then return end

				local newCount = #game:GetService("Players").LocalPlayer.Backpack:GetChildren()

				if newCount > oldCount then
					DebugLog("Изменение: " .. oldCount .. " -> " .. newCount)
					oldCount = newCount

					if NewMwthod == false then
						-- Ищем ТОЛЬКО нашего клона
						local targetMerchant = findMerchant()
								
						if not targetMerchant then
								DebugLog("Клон мерчанта не найден")
							return
						end
								
						if not targetMerchant.description then
							DebugLog("Ошибка: у клона нет description")
							return
						end
					end

					isSelling = true
					lastSaleTime = currentTime
						
					SellALL()
						
					isSelling = false
				else
					oldCount = newCount
				end
			end

			-- Чекбокс для AutoSell
			local AutoSellLoop = nil
			local AutoSell = Main:Toggle({
				Title = "AutoSell",
				Type = "Checkbox",
				Value = false, -- default value
				Callback = function(state) 
					if state == true then
						AutoSellLoop = RunService.Heartbeat:Connect(function()
							if IsUnloaded then
								AutoSellLoop:Disconnect()
								return
							end
							processAutoSell()
						end)
						DebugLog("AutoSell включен")
					else
						if AutoSellLoop then
							AutoSellLoop:Disconnect()
							AutoSellLoop = nil
						end
						DebugLog("AutoSell выключен")
					end
				end
			})


			local WarningMode
			WarningMode = Main:Toggle({
				Title = "Warning Mode",
				--Desc = "Toggle Description",
				--Icon = "bird",
				Type = "Checkbox",
				Value = true, -- default value
			})

			local Sell_in_Hand = Main:Button({
				Title = "Sell in Hand",
				Callback = function()
					if WarningMode.Value then
						Window:Dialog({
							Title = "Are you sure?",
							Content = "Are you sure you want to sell fish directly from your hands?",
							Buttons = {
								{
									Title = "Confirm",
									Callback = function()
										SellOne()
									end
								},
								{
									Title = "Cancel", 
									Callback = function()
										DebugLog("Cancelled!")
									end
								}
							}
						})
					else
						SellOne()
					end
				end
			})

			local Sell_All = Main:Button({
				Title = "Sell All",
				Callback = function()
					if WarningMode.Value then
						Window:Dialog({
							Title = "Are you sure?",
							Content = "Are you sure you want to sell all the fish in your inventory (the fish will be sold according to your sale settings)",
							Buttons = {
								{
									Title = "Confirm",
									Callback = function()
										SellALL()
									end
								},
								{
									Title = "Cancel",
									Callback = function()
										DebugLog("Cancelled!")
									end
								}
							}
						})
					else
						SellALL()
					end
				end
			})
		end
	end


	do
		local NPS = Automatic:Tab(
			{
				Title = "NPS",
				Icon = "lucide:users"
			}
		)

		do
			local Treasure = NPS:Section(
				{
					Title = "Treasure"
				}
			)

			-- // Treasure Tab // --
			local Teleport_to_Jack_Marrow = NPS:Button(
				{
					Title = "Teleport to Jack Marrow",
					Callback = function()
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
							CFrame.new(-2824.359, 214.311, 1518.130)
					end
				}
			)

			-- Ждем только если пауза
			function waitIfPaused()
				while game:GetService("Players").LocalPlayer.GameplayPaused do
					wait(0.1)
				end
				wait(0.1)
			end

			local function debugLookAt(target)
				local camera = workspace.CurrentCamera
				local currentPos = camera.CFrame.Position

				-- Находим подходящую часть для прицеливания
				local targetPart

				if target:IsA("Model") then
					targetPart =
						target:FindFirstChild("Head") or target:FindFirstChild("HumanoidRootPart") or
						target:FindFirstChildWhichIsA("BasePart")
				elseif target:IsA("BasePart") then
					targetPart = target
				end

				if targetPart then
					local targetPos = targetPart.Position
					-- Используем LookVector для более плавного поворота
					local lookVector = (targetPos - currentPos).Unit
					camera.CFrame = CFrame.new(currentPos, currentPos + lookVector)
					return true
				else
					DebugWarn("Не найдена подходящая часть у модели: " .. target.Name)
					return false
				end
			end

			local Repair_Map = NPS:Button(
				{
					Title = "Repair Map",
					Callback = function()
						for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
							if v.Name == "Treasure Map" then
								for i = 0, 30 do
									debugLookAt(workspace.world.npcs["Jack Marrow"])
									task.wait()
								end

								waitIfPaused()

								local prompt = workspace.world.npcs["Jack Marrow"].dialogprompt
								fireproximityprompt(prompt)

								game.Players.LocalPlayer.Character.Humanoid:EquipTool(v)

								local remote = workspace.world.npcs["Jack Marrow"].treasure.repairmap
								local arguments = {
									[1] = {
										["npc"] = workspace.world.npcs["Jack Marrow"],
										["idle"] = workspace.world.npcs["Jack Marrow"].description.idle,
										["voice"] = 12
									}
								}
								remote:InvokeServer(unpack(arguments))
							end
						end
					end
				}
			)

			local Collect_Treasure = NPS:Button(
				{
					Title = "Collect Treasure",
					Callback = function()
						-- Сначала находим все сундуки и меняем только их промпты
						for i, chest in pairs(workspace.world.chests:GetDescendants()) do
							if chest:IsA("Part") and chest:FindFirstChild("ChestSetup") then
								local prompt = chest:FindFirstChild("ProximityPrompt")
								if prompt then
									prompt.HoldDuration = 0
									prompt.RequiresLineOfSight = false
									prompt.MaxActivationDistance = 9999
								end
							end
						end

						local oldPos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

						-- Собираем сундуки
						for i, chest in pairs(workspace.world.chests:GetDescendants()) do
							if chest:IsA("Part") and chest:FindFirstChild("ChestSetup") then
								-- Телепортируемся к сундуку
								game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
									chest.CFrame * CFrame.new(0, 0, 3) -- Встаем перед сундуком

								-- Увеличиваем время ожидания для стабилизации
								task.wait(0.8)
								waitIfPaused()

								-- Поворачиваем камеру на сундук (больше попыток)
								for i = 1, 15 do
									debugLookAt(chest)
									task.wait(0.03) -- Более частые обновления
								end

								task.wait(0.2)

								-- Ищем промпт именно этого сундука
								local prompt = chest:FindFirstChild("ProximityPrompt")
								if prompt then
									fireproximityprompt(prompt)
									-- Увеличиваем время ожидания после взаимодействия
									task.wait(0.8)
								end
							end
						end

						-- Возвращаем на исходную позицию
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldPos
					end
				}
			)
		end
	end





--[[
    local Optional = Automatic:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })
]]
end



-- Market 
do

	--Main
	do
		local Main = Market:Tab({
			Title = "Main",
			Icon = "lucide:package"
		})
		
		local RodsSection = Main:Section({ Title = "  Rods", })
		

		local Rods = {"None",}
		local RodsStats = {}
		local RodInformation

		-- Исправленный код для удочек
		for rodName, rodData in pairs(Rods_Module) do
			if type(rodData) == "table" then
				local price = rodData.Price
				local Luck = rodData.Luck
				local LureSpeed = rodData.LureSpeed
				local LineDistance = rodData.LineDistance
				local Resilience = rodData.Resilience
				local Control = rodData.Control
				local Strength = rodData.Strength
				local Icon = rodData.Icon

				-- Если цена не число или равна math.huge, то заменяем на nil
				if type(price) ~= "number" or price == math.huge then
					price = nil
				end

				if type(Strength) ~= "number" then
					Strength = "nil"
				else
					if Strength == math.huge then
						Strength = "inf"
					end
				end


				if price ~= nil then
					table.insert(Rods, rodName)
					RodsStats[rodName] = {
						Luck = Luck,
						LureSpeed = 100 - LureSpeed,
						LineDistance = LineDistance,
						Resilience = Resilience,
						Strength = Strength,
						Control = Control,
						Price = price,
						Icon = Icon,
					}
				end
			end
		end

		-- Функция для обновления информации о предмете
		local function updateRodsInfo(option)
			local Value = option
			
			if Value ~= nil and Value ~= "None" then
				local infoText = " LureSpeed: " .. RodsStats[Value].LureSpeed .. "%" .. "\n" ..
								" Luck: " .. RodsStats[Value].Luck .. "%" .. "\n" ..
								" Control: " .. RodsStats[Value].Control .. "\n" ..
								" Resilience: " .. RodsStats[Value].Resilience .. "%" .. "\n" ..
								" Max Kg: " .. RodsStats[Value].Strength .. "kg" .. "\n" ..
								" Price: " .. RodsStats[Value].Price .. " C$"

				RodInformation:SetTitle("Rod: ".. Value)
				RodInformation:SetDesc(infoText)

				--RodInformation:SetIcon(RodsStats[Value].Icon, "title-right")
			else
				RodInformation:SetTitle("Rod Information")
				RodInformation:SetDesc("Select a Rod to see details")

				--RodInformation:RemoveIcon()
			end
		end


		local DRodsSelect = Main:Dropdown({
			Title = "Selet Your Rod",
			Values = Rods,
			SearchBarEnabled = true,
			Value = "None",
			Callback = function(option) 
				updateRodsInfo(option)
			end
		})


		local function BuyRod(RodName)
			DebugLog("Куплена Удочка: ".. RodName)
			local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
			purchaseEvent:FireServer(RodName, "Rod", nil, 1)
		end

		RodInformation = Main:Paragraph({
			Title = "Rod Information",
			Desc = "Select a rod to see price",
			Locked = false,
			Buttons = {
				{
					Icon = "bird",
					Title = "Buy Rod",
					Callback = function()
						if DRodsSelect.Value ~= nil and DRodsSelect.Value ~= "None" then
							Window:Dialog({
								Title = "You want to buy it?",
								Content = "(if you already have this fishing rod, the money will be debited again)",
								Buttons = {
									{
										Title = "Confirm",
										Callback = function()
											BuyRod(DRodsSelect.Value)
										end
									},
									{
										Title = "Cancel",
										Callback = function()
											DebugLog("Cancelled Buy Rod")
										end
									}
								}
							})
							--DRodsSelect:SetValue("None")
						end
					end,
				}
			}
		})


		local ItemsSection = Main:Section({ Title = "  Items", })

		local Items = {"None",}
		local ItemsPrise = {}
		local ItemsOnlyOne = {}

		for itemName, itemData in pairs(Items_Module.Items) do
			if type(itemData) == "table" then
				local price = itemData.Price
				local OnlyOne

				if itemData.OnlyBuyOne then
					OnlyOne = true
				else
					OnlyOne = false
				end

				-- Если цена не число или равна math.huge, то заменяем на nil
				if type(price) ~= "number" or price == math.huge then
					price = nil
				end
				if price ~= nil and itemName ~= "Witches Ingredient" then

					table.insert(Items, itemName)
					ItemsPrise[itemName] = price -- Исправлено: используем таблицу как словарь
					ItemsOnlyOne[itemName] = OnlyOne -- Исправлено: используем таблицу как словарь

					--DebugLog(itemName .. " - " .. tostring(price), OnlyOne)
				end
			end
		end


		local CountItemInput
		local DItemSelect
		local ItemInformation

		-- Функция для обновления информации о предмете
		local function updateItemInfo()
			local Value = DItemSelect.Value
			
			if Value ~= nil and Value ~= "None" then
				local price = ItemsPrise[Value] or "Unknown"
				local OnlyOne = ItemsOnlyOne[Value] or false

				local Count = tonumber(CountItemInput.Value) or 1
				if type(price) ~= "number" or OnlyOne then
					Count = 1
				end

				local TotalPrice
				if type(price) == "number" then
					TotalPrice = Count * price
				else
					TotalPrice = 0
				end

				local infoText = " Price Once: " .. tostring(price) .. " C$" .. "\n" ..
								" Count: " .. Count .. "pcs" .. "\n" ..
								" Buy Only One: " .. tostring(OnlyOne) ..  "\n" ..
								" Total Price: " .. TotalPrice .. " C$"
								

				ItemInformation:SetTitle("Item: ".. Value)
				ItemInformation:SetDesc(infoText)
			else
				ItemInformation:SetTitle("Item Information")
				ItemInformation:SetDesc("Select a Item to see details")
			end
		end


		DItemSelect = Main:Dropdown({
			Title = "Item Select",
			--Desc = "Dropdown Description",
			Values = Items,
			Value = "Nane",
			SearchBarEnabled = true,
			Callback = function(option) 
				updateItemInfo()
			end
		})


		CountItemInput = Main:Input({
			Title = "Count",
			Value = "1",
			--InputIcon = "bird",
			Type = "Input", -- or "Textarea"
			Placeholder = "example 1173",
			Callback = function(input) 
				updateItemInfo()
			end
		})

		local function BuyItem(ItemName, Value)
			if not Value then Value = 1 end
			
			DebugLog("Куплен Предмет: ".. ItemName)
			local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
			
			while Value > 0 do
				local purchaseAmount = math.min(Value, 50)
				purchaseEvent:FireServer(ItemName, "Item", nil, purchaseAmount)
				Value = Value - purchaseAmount
				if Value > 0 then
					wait(0.1)  -- Задержка между запросами
				end
			end
		end

		ItemInformation = Main:Paragraph({
			Title = "Items Information",
			Desc = "Select a Item to see price",
			Locked = false,
			Buttons = {
				{
					Icon = "bird",
					Title = "Buy Item",
					Callback = function()
						if DItemSelect.Value ~= nil and DItemSelect.Value ~= "None" then
							Window:Dialog({
								Title = "You want to buy it?",
								Content = "(if you already have this Item, the money will be debited again)",
								Buttons = {
									{
										Title = "Confirm",
										Callback = function()
											local OnlyOne = ItemsOnlyOne[DItemSelect.Value] or false
											local Count = 1
											if OnlyOne then
												Count = 1
											else
												Count = tonumber(CountItemInput.Value) or 1
											end
											BuyItem(DItemSelect.Value, Count)
										end
									},
									{
										Title = "Cancel",
										Callback = function()
											DebugLog("Cancelled Buy Item")
										end
									}
								}
							})
							--DItemSelect:SetValue("None")
						end
					end,
				}
			}
		})

		local FishesSection = Main:Section({ Title = "  Fishes", })
		local Fish = {"None", }
		local FishBuyPrice = {}

		-- Вывод всех рыб с учетом BuyMult
		for fishName, fishData in pairs(Fish_Module) do
			if fishName ~= "Rarities" and fishName ~= "RarityColours" and type(fishData) == "table" then
				local basePrice = fishData.Price or 0
				local buyMult = fishData.BuyMult or 1
				local finalPrice = basePrice * buyMult
				
				-- Выводим только если есть BuyMult (или всегда, но с учетом множителя)
				if fishData.BuyMult and fishName ~= "Bloop Cosmetic Crate" then
					--DebugLog(fishName .. " - " .. finalPrice .. " монет (множитель: " .. buyMult .. ")")
					table.insert(Fish, fishName)
					FishBuyPrice[fishName] = finalPrice
				else
					--DebugLog(fishName .. " - " .. finalPrice .. " монет")
				end
			end
		end

		local DFishesSelect
		local CountFishesInput
		local FishesInformation

		-- Функция для обновления информации о предмете
		local function updateFishesInfo()
			local Value = DFishesSelect.Value
			
			if Value ~= nil and Value ~= "None" then
				local price = FishBuyPrice[Value] or "Unknown"

				local Count = tonumber(CountFishesInput.Value) or 1
				if type(price) ~= "number" then
					Count = 1
				end

				local ToralPrice = Count * price
				local infoText = " Price Once: " .. price .. " C$" .. "\n"..
									" Count: " .. Count .. "pcs" .. "\n"..
									" Total Price: " .. ToralPrice .. " C$"

				FishesInformation:SetTitle("Item: ".. Value)
				FishesInformation:SetDesc(infoText)
			else
				FishesInformation:SetTitle("Item Information")
				FishesInformation:SetDesc("Select a Item to see details")
			end
		end

		DFishesSelect = Main:Dropdown({
			Title = "Fishes Select",
			--Desc = "Dropdown Description",
			Values = Fish,
			Value = "Nane",
			SearchBarEnabled = true,
			Callback = function(option) 
				updateFishesInfo()
			end
		})

		CountFishesInput = Main:Input({
			Title = "Count",
			Value = "1",
			--InputIcon = "bird",
			Type = "Input", -- or "Textarea"
			Placeholder = "example 1173",
			Callback = function(input) 
				updateFishesInfo()
			end
		})

		--[[
		local function BuyFish(FishName, Value)
			if not Value then
				Value = 1
			end

			DebugLog("Куплен Предмет: ".. FishName)
			local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
			
			-- Если значение больше 50, разбиваем на части
			if Value > 50 then
				local fullPurchases = math.floor(Value / 50)  -- Количество покупок по 50
				local remainder = Value % 50                  -- Остаток
				
				-- Покупаем полные части по 50
				for i = 1, fullPurchases do
					purchaseEvent:FireServer(FishName, "Fish", nil, 50)
					wait(0.1)  -- Небольшая задержка между запросами
				end
				
				-- Покупаем остаток, если он есть
				if remainder > 0 then
					purchaseEvent:FireServer(FishName, "Fish", nil, remainder)
				end
			else
				-- Если значение 50 или меньше, покупаем сразу всё
				purchaseEvent:FireServer(FishName, "Fish", nil, Value)
			end
		end
		]]

		local function BuyFish(FishName, Value)
			if not Value then Value = 1 end
			
			DebugLog("Куплен Предмет: ".. FishName)
			local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
			
			while Value > 0 do
				local purchaseAmount = math.min(Value, 50)
				purchaseEvent:FireServer(FishName, "Fish", nil, purchaseAmount)
				Value = Value - purchaseAmount
				if Value > 0 then
					wait(0.1)  -- Задержка между запросами
				end
			end
		end

		FishesInformation = Main:Paragraph({
			Title = "Fish Information",
			Desc = "Select a Item to see price",
			Locked = false,
			Buttons = {
				{
					Icon = "bird",
					Title = "Buy Fish",
					Callback = function()
						if DFishesSelect.Value ~= nil and DFishesSelect.Value ~= "None" then
							Window:Dialog({
								Title = "You want to buy it?",
								Content = "(if you already have this Fish, the money will be debited again)",
								Buttons = {
									{
										Title = "Confirm",
										Callback = function()
											BuyFish(DFishesSelect.Value, tonumber(CountFishesInput.Value) or 1)
										end
									},
									{
										Title = "Cancel",
										Callback = function()
											DebugLog("Cancelled Buy Fish")
										end
									}
								}
							})
							--DFishesSelect:SetValue("None")
						end
					end,
				}
			}
		})




		local SpearsSection = Main:Section({ Title = "  Spears", })
		local Spear = {"None", }
		local SpearStats = {}

		for spearName, spearData in pairs(Spears_Module) do
			if type(spearData) == "table" then
				local Price = spearData.Price
				local Power = spearData.Power
				local Handling = spearData.Handling
				local Piercing = spearData.Piercing
				
				-- Если цена не число или равна -1, то заменяем на nil
				if type(Price) ~= "number" or Price == -1 then
					Price = nil
				end

				if Price ~= nil then
					table.insert(Spear, spearName)
					SpearStats[spearName] = {
						Power = Power,
						Handling = Handling,
						Piercing = Piercing,
						Price = Price
					}
				end
			end
		end



		local SpearInformation
		local DSpearSelect

		-- Функция для обновления информации о предмете
		local function updateSpearsInfo()
			local Value = DSpearSelect.Value
			
			if Value ~= nil and Value ~= "None" then
				local infoText = " Power: " .. SpearStats[Value].Power .. "\n" ..
								" Handling: " .. SpearStats[Value].Handling .. "\n" ..
								" Piercing: " .. SpearStats[Value].Piercing .. "\n" ..
								" Price: " .. SpearStats[Value].Price

				SpearInformation:SetTitle("Spear: ".. Value)
				SpearInformation:SetDesc(infoText)
			else
				SpearInformation:SetTitle("Spear Information")
				SpearInformation:SetDesc("Select a spear to see details")
			end
		end
		
		DSpearSelect = Main:Dropdown({
			Title = "Spear Select",
			Values = Spear,
			Value = "Nane",
			SearchBarEnabled = true,
			Callback = function(option) 
				updateSpearsInfo()
			end
		})


		local function BuySpear(SpearName)
			DebugLog("Куплено Копьё: ".. SpearName)
			local purchaseEvent = game:GetService("ReplicatedStorage").events.purchase
			purchaseEvent:FireServer(SpearName, "Spear", nil, 1)
		end

		SpearInformation = Main:Paragraph({
			Title = "Spear Information",
			Desc = "Select a spear to see price",
			Locked = false,
			Buttons = {
				{
					Icon = "bird",
					Title = "Buy Spear",
					Callback = function()
						if DSpearSelect.Value ~= nil and DSpearSelect.Value ~= "None" then
							Window:Dialog({
								Title = "You want to buy it?",
								Content = "(if you already have this Spear, the money will be debited again)",
								Buttons = {
									{
										Title = "Confirm",
										Callback = function()
											BuySpear(DSpearSelect.Value)
										end
									},
									{
										Title = "Cancel",
										Callback = function()
											DebugLog("Cancelled Buy Spear")
										end
									}
								}
							})
							--DSpearSelect:SetValue("None")
						end
					end,
				}
			}
		})

	end

do
    local NPS = Market:Tab({
        Title = "NPS",
        Icon = "lucide:handshake"
    })

	do
		local Teleport_To_Merlin
		Teleport_To_Merlin = NPS:Button({
			Title = "Teleport To Merlin",
			Description = "", --"Very important button",
			Callback = function()

				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-927.5850830078125, 223.70001220703125, -997.9788208007812)	

				Buy_Relic:Highlight()
				WindUI:Notify({
					Title = "Market",
					Content = "You have bought" .. tonumber(RelicAmount.Value) .. "Relics",
					Duration = 3, -- 3 seconds
				})
			end
		})
	end

	do
		local LuckAmount = NPS:Input({
			Title = "Luck Amount",
			Desc = "Input Description",
			Value = "1",
			InputIcon = "bird",
			Type = "Input", -- or "Textarea"
			Placeholder = "Placeholder",
		})

		local function BuyMerlinLuck(Value)
			for i = 1, Value do
				local BuyLuckEvent = workspace.world.npcs.Merlin.Merlin:GetChildren()[9]
				local arguments = {
					[1] = {
						--["npc"] = workspace.world.npcs.Merlin,
						--["idle"] = workspace.world.npcs.Merlin.description.idle,
						--["voice"] = workspace.world.npcs.Merlin.description.voice
					}
				}
				BuyLuckEvent:InvokeServer(unpack(arguments))
			end
		end
	
		local Buy_Luck
		Buy_Luck = NPS:Button({
			Title = "Buy Luck",
			Description = "", --"Very important button",
			Callback = function()
				Buy_Luck:Highlight()
				Window:Dialog({
					Icon = "bird",
					Title = "You want to buy it?",
					Content = "",
					Buttons = {
						{
							Title = "Confirm",
							Callback = function()
								BuyMerlinLuck(tonumber(LuckAmount.Value))
								WindUI:Notify({
									Title = "Market",
									Content = "You have bought " .. tonumber(LuckAmount.Value) .. " Luck",
									Duration = 3, -- 3 seconds
								})
							end
						},
						{
							Title = "Cancel",
							Callback = function()
								DebugLog("Cancelled Buy Luck")
							end,
						},
					},
				})
			end
		})
	end

	-- Buy Relic
	do
		local function BuyMerlinRelick(Value)
			local needValue = Value
			
			local remote0 = workspace.world.npcs.Merlin.Merlin:GetChildren()[3] --1 relic
			local remote1 = workspace.world.npcs.Merlin.Merlin.buy2Relics --2 relic
			local remote2 = workspace.world.npcs.Merlin.Merlin.buy5Relics --5 relic
			local remote3 = workspace.world.npcs.Merlin.Merlin.buy10Relics --10 relic
			local remote4 = workspace.world.npcs.Merlin.Merlin.buy25Relics --25 relic
			local remote5 = workspace.world.npcs.Merlin.Merlin.buy50Relics --50 relic
			
			local arguments = {
				[1] = {
					--["npc"] = workspace.world.npcs.Merlin,
					--["idle"] = workspace.world.npcs.Merlin.description.idle,
					--["voice"] = 11
				}
			}
			
			-- Массив с доступными пакетами реликов в порядке убывания
			local packages = {
				{value = 50, remote = remote5},
				{value = 25, remote = remote4},
				{value = 10, remote = remote3},
				{value = 5, remote = remote2},
				{value = 2, remote = remote1},
				{value = 1, remote = remote0}
			}
			
			-- Покупаем пакеты от большего к меньшему
			for _, package in ipairs(packages) do
				while needValue >= package.value do
					local results = package.remote:InvokeServer(unpack(arguments))
					needValue = needValue - package.value
					
					-- Небольшая задержка между запросами чтобы избежать проблем
					wait(0.1)
				end
			end
			
			return true
		end

		local RelicAmount = NPS:Input({
			Title = "Relic Amount",
			Desc = "Input Description",
			Value = "1",
			InputIcon = "bird",
			Type = "Input", -- or "Textarea"
			Placeholder = "Placeholder",
		})

		local Buy_Relic
		Buy_Relic = NPS:Button({
			Title = "Buy Relic",
			Description = "You need to teleport and talk to him to purchase further.", --"Very important button",
			Callback = function()

				Buy_Relic:Highlight()
				Window:Dialog({
					Icon = "bird",
					Title = "You want to buy it?",
					Content = "If you confirm the payment, it will be impossible to return the purchase.",
					Buttons = {
						{
							Title = "Confirm",
							Callback = function()
								BuyMerlinRelick(tonumber(RelicAmount.Value))
								WindUI:Notify({
									Title = "Market",
									Content = "You have bought " .. tonumber(RelicAmount.Value) .. " Relics",
									Duration = 3, -- 3 seconds
								})
							end
						},
						{
							Title = "Cancel",
							Callback = function()
								DebugLog("Cancelled Buy Relic")
							end,
						},
					},
				})
			end
		})
	end
end


--[[
    local Optional = Market:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })
]]
end

-- Player 
do
    local MainTab = Player:Tab({
        Title = "Main",
        Icon = "lucide:user-check"
    })

-- Создаем переменные для хранения значений
local currentWalkSpeed = 16
local currentJumpHeight = 7.2
local currentJumpPower = 50

-- Character Settings Section
local CharacterSection = MainTab:Section({
    Title = "Character Settings"
})

-- WalkSpeed Toggle
local WalkSpeedLoop = nil
local WalkSpeedToggle = MainTab:Toggle({
    Title = "WalkSpeed",
    Default = false,
    Callback = function(state)
        if state == true then
            WalkSpeedLoop = RunService.Heartbeat:Connect(function()
                -- Проверка на выгрузку скрипта
                if IsUnloaded then 
                    if WalkSpeedLoop then
                        WalkSpeedLoop:Disconnect()
                        WalkSpeedLoop = nil
                    end
                    if LHumanoid then
                        LHumanoid.WalkSpeed = originalWalkSpeed
                    end
                    return
                end

                if LHumanoid and LHumanoid.Parent then
                    LHumanoid.WalkSpeed = currentWalkSpeed
                end
            end)
        else
            if WalkSpeedLoop then
                WalkSpeedLoop:Disconnect()
                WalkSpeedLoop = nil
            end
            if LHumanoid then
                LHumanoid.WalkSpeed = originalWalkSpeed
            end
        end
    end
})

-- WalkSpeed Slider
local WalkSpeedSlider = MainTab:Slider({
    Title = "WalkSpeed Value",
    Step = 1,
    Value = {
        Min = 16,
        Max = 200,
        Default = 16,
    },
    Callback = function(value)
        currentWalkSpeed = value
        if WalkSpeedToggle.Value == true and LHumanoid and LHumanoid.Parent then
            LHumanoid.WalkSpeed = value
        end
    end
})

-- JumpHeight Toggle
local JumpHeightLoop = nil
local JumpHeightToggle = MainTab:Toggle({
    Title = "JumpHeight", 
    Default = false,
    Callback = function(state)
        if state == true then
            JumpHeightLoop = RunService.Heartbeat:Connect(function()
                -- Проверка на выгрузку скрипта
                if IsUnloaded then 
                    if JumpHeightLoop then
                        JumpHeightLoop:Disconnect()
                        JumpHeightLoop = nil
                    end
                    if LHumanoid then
                        LHumanoid.JumpHeight = originalJumpHeight
                    end
                    return
                end

                if LHumanoid and LHumanoid.Parent then
                    LHumanoid.JumpHeight = currentJumpHeight
                end
            end)
        else
            if JumpHeightLoop then
                JumpHeightLoop:Disconnect()
                JumpHeightLoop = nil
            end
            if LHumanoid then
                LHumanoid.JumpHeight = originalJumpHeight
            end
        end
    end
})

-- JumpHeight Slider
local JumpHeightSlider = MainTab:Slider({
    Title = "JumpHeight Value",
    Step = 1,
    Value = {
        Min = 7.2,
        Max = 200,
        Default = 7.2,
    },
    Callback = function(value)
        currentJumpHeight = value
        if JumpHeightToggle.Value == true and LHumanoid and LHumanoid.Parent then
            LHumanoid.JumpHeight = value
        end
    end
})

-- JumpPower Toggle
local JumpPowerLoop = nil
local JumpPowerToggle = MainTab:Toggle({
    Title = "JumpPower",
    Default = false,
    Callback = function(state)
        if state == true then
            JumpPowerLoop = RunService.Heartbeat:Connect(function()
                -- Проверка на выгрузку скрипта
                if IsUnloaded then 
                    if JumpPowerLoop then
                        JumpPowerLoop:Disconnect()
                        JumpPowerLoop = nil
                    end
                    if LHumanoid then
                        LHumanoid.JumpPower = originalJumpPower
                    end
                    return
                end

                if LHumanoid and LHumanoid.Parent then
                    LHumanoid.JumpPower = currentJumpPower
                end
            end)
        else
            if JumpPowerLoop then
                JumpPowerLoop:Disconnect()
                JumpPowerLoop = nil
            end
            if LHumanoid then
                LHumanoid.JumpPower = originalJumpPower
            end
        end
    end
})

-- JumpPower Slider
local JumpPowerSlider = MainTab:Slider({
    Title = "JumpPower Value",
    Step = 1,
    Value = {
        Min = 50,
        Max = 200,
        Default = 50,
    },
    Callback = function(value)
        currentJumpPower = value
        if JumpPowerToggle.Value == true and LHumanoid and LHumanoid.Parent then
            LHumanoid.JumpPower = value
        end
    end
})

-- Other Character Functions
MainTab:Button({
    Title = "Sit Down",
    Callback = function()
        sit_down(true)
    end
})

MainTab:Button({
    Title = "Stand Up", 
    Callback = function()
        sit_down(false)
    end
})

MainTab:Button({
    Title = "Suicide V1",
    Callback = function()
        Suicide()
    end
})

MainTab:Button({
    Title = "Suicide V2",
    Callback = function()
        SuicideV2()
    end
})

--[[
    local Optional = Player:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })
]]
end


-- Teleport 
do
	do
		local LocationORZones = Teleport:Tab({
			Title = "Location/Zones",
			Icon = "lucide:map-pin"
		})

		-- Таблица с координатами локаций
		local locations = {
			["Enchant Altar"] = CFrame.new(1310.7498779296875, -802.427001953125, -84.14505767822266),
			["Moosewood"] = CFrame.new(468.4601745605469, 150.6934051513672, 266.5889892578125),
			["Roslit"] = CFrame.new(-1510.43310546875, 133.00001525878906, 615.421875),
			["Snowcap"] = CFrame.new(2689.964599609375, 152.81431579589844, 2382.687744140625),
			["Sunstone"] = CFrame.new(-1059.8160400390625, 138.38648986816406, -1147.626708984375),
			["Vertigo"] = CFrame.new(-100.74667358398438, -513.2993774414062, 1053.50244140625),
			["Desolate Deep"] = CFrame.new(-1666.7783203125, -214.1810302734375, -2838.974853515625),
			["Forsaken Shores"] = CFrame.new(-2530.197509765625, 135.25001525878906, 1558.6446533203125),
			["Ancient Isle"] = CFrame.new(6072.98291015625, 195.18016052246094, 296.28118896484375),
			["The Depths"] = CFrame.new(954.4327392578125, -711.662109375, 1217.8978271484375),
			["Northern Summit"] = CFrame.new(19537.888671875, 132.67010498046875, 5295.79638671875),
			["Frigid Cavern"] = CFrame.new(19759.77734375, 415.43707275390625, 5402.3203125),
			["Cryogenic Canal"] = CFrame.new(20303.177734375, 706.5989990234375, 5767.0732421875),
			["Glacial Grotto"] = CFrame.new(19903.4453125, 1154.770263671875, 5510.076171875),
			["Atlantis"] = CFrame.new(-4252.130859375, -603.4038696289062, 1830.807373046875),
			["Challenger Deep"] = CFrame.new(-778.5140380859375, -3283.211181640625, -667.571044921875),
			["Volcanic Vents"] = CFrame.new(-3407.9072265625, -2260.38232421875, 3856.470947265625),
			["Abyssal Zenith"] = CFrame.new(-13502.2431640625, -11050.1884765625, 127.95650482177734),
			["Calm Zone"] = CFrame.new(-4234.89208984375, -11201.2109375, 1786.04541015625),
			["Castaway Cliffs"] = CFrame.new(645.3287963867188, 160.99998474121094, -1788.6729736328125),
			["Crystal Cove"] = CFrame.new(1368.512939453125, -614.0402221679688, 2455.83544921875),
			["Terrapin"] = CFrame.new(-224.14453125, 153.77735900878906, 1933.1331787109375),
			["Luminescent Cavern"] = CFrame.new(-1008.2897338867188, -336.3400573730469, -4076.955078125),
			["Lost Jungles"] = CFrame.new(-2710.125, 150.24826049804688, -2051.906494140625),
			["Crimson Cavern"] = CFrame.new(-1031.912109375, -354.1904296875, -4851.046875),
			["Scylla"] = CFrame.new(-2348.7109375, -11183.4892578125, 7071.1806640625),
			["Kraken Pool"] = CFrame.new(-4301.30712890625, -1001.360107421875, 2004.2734375),
			["Mossjaw Hunt"] = CFrame.new(-4909.92333984375, -1790.561279296875, -10162.6962890625),
			["Mushgrove Swamp"] = CFrame.new(2433.88232421875, 131.62515258789062, -673.1868896484375),
			["Carrot Garden"] = CFrame.new(3705.1044921875, -1127.6787109375, -1092.2685546875),
		}

		-- Функция для телепортации к локации
		local function teleportToLocation(locationName)
			if locationName == nil then
				return
			end
			
			local locationCFrame = locations[locationName]
			if locationCFrame then
				local character = game.Players.LocalPlayer.Character
				if character and character:FindFirstChild("HumanoidRootPart") then
					character.HumanoidRootPart.CFrame = locationCFrame
					WindUI:Notify({
						Title = "Teleport",
						Content = "Teleported to " .. locationName,
						Icon = "check"
					})
				else
					WindUI:Notify({
						Title = "Error",
						Content = "Character not found!",
						Icon = "x"
					})
				end
			else
				WindUI:Notify({
					Title = "Error",
					Content = "Location not found!",
					Icon = "x"
				})
			end
		end

		-- Создаем лист для выбора локаций
		local locationNames = {}
		for locationName, _ in pairs(locations) do
			table.insert(locationNames, locationName)
		end
		table.sort(locationNames) -- Сортируем по алфавиту
		-- Добавляем "None" на первую позицию
		table.insert(locationNames, 1, "None")

		local locationDropdown = LocationORZones:Dropdown({
			Title = "Select Location",
			Desc = "Choose location to teleport",
			AllowNone = true,
			SearchBarEnabled = true,
			Values = locationNames,
			Value = "None",
		})

		local TeleportToLocation
		TeleportToLocation = LocationORZones:Button({
			Title = "Teleport to Select",
			Desc = "Teleporting you to selected location",
			Callback = function()
				local Value = locationDropdown.Value
				if Value ~= "None" then
					teleportToLocation(Value)
					TeleportToLocation:Highlight()
				end
			end
		})
	
	
		local Old_pos
		local inSafePlase = false
		local TeleportToSafePlase
		TeleportToSafePlase = LocationORZones:Button({
			Title = "Create Safe Place",
			Desc = "Create a safe zone high in the sky",
			Callback = function()
				if not inSafePlase then
					inSafePlase = true
					local Players = game:GetService("Players")
					local LocalPlayer = Players.LocalPlayer
					local playerName = LocalPlayer.Name

					Old_pos = workspace[playerName].HumanoidRootPart.Position

					local targetCharacter = workspace:WaitForChild(playerName)
					local HumanoidRootPart = targetCharacter:WaitForChild("HumanoidRootPart")

					local currentRotation = HumanoidRootPart.CFrame.Rotation

					local SafeZone = Instance.new("Part")
					SafeZone.Size = Vector3.new(30, 1, 30)
					SafeZone.Position = Vector3.new(math.random(-2000,2000), math.random(50000,90000), math.random(-2000,2000))
					SafeZone.Anchored = true
					SafeZone.BrickColor = BrickColor.new("Bright purple")
					SafeZone.Material = Enum.Material.ForceField
					SafeZone.Parent = game.Workspace
					
					HumanoidRootPart.CFrame = CFrame.new(SafeZone.Position + Vector3.new(0, 5, 0)) * currentRotation

					WindUI:Notify({
						Title = "Teleport",
						Icon = "shield",
						Content = "Teleporting in safe place",
						Duration = 3, -- 3 seconds
					})

					TeleportToSafePlase:Highlight()
				end
			end
		})
		local ReturnOfSafePlase
		ReturnOfSafePlase = LocationORZones:Button({
			Title = "Return",
			Desc = "Return to original position",
			Callback = function()
				if Old_pos then
					local character = workspace[game:GetService("Players").LocalPlayer.Name]
					local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
					humanoidRootPart.CFrame = CFrame.new(Old_pos) * humanoidRootPart.CFrame.Rotation
					ReturnOfSafePlase:Highlight()

					WindUI:Notify({
						Title = "Teleport",
						Content = "Returning from safe place",
						Duration = 3, -- 3 seconds
						Icon = "arrow-left",
					})

					inSafePlase = false
				end
			end
		})
	
		local CopyXYZType = LocationORZones:Dropdown({
			Title = "Copy XYZ Type", 
			Values = {"CFrame Script", "Coordinates Only"},
			Multi = false,
			Value = "CFrame Script",
		})

		local CopyPosition
		CopyPosition = LocationORZones:Button({
			Title = "Copy XYZ",
			Description = "Copy position to clipboard",
			Callback = function()
				local XYZ = tostring(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)

				if CopyXYZType.Value == "CFrame Script" then
					setclipboard("game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(" .. XYZ .. ")")
				else
					setclipboard(XYZ)
				end

				CopyPosition:Highlight()

				WindUI:Notify({
					Title = "Copied to clipbord",
					Content = "XYZ " .. tostring(CopyXYZType.Value) .. " copied!",
					Duration = 3, -- 3 seconds
					Icon = "copy",
				})
			end
		})

		local Cordinats = LocationORZones:Input({
			Title = "Cords",
			Desc = "Input Description",
			Value = "",
			InputIcon = "bird",
			Type = "Input", -- or "Textarea"
			Placeholder = "0, 0, 0",
		})

		local TeleportToCords
		TeleportToCords = LocationORZones:Button({
			Title = "Teleport to Cords",
			Description = "Писать через запятую",
			Callback = function()
				local XYZ = Cordinats.Value
				local x, y, z = string.match(XYZ, "([%d%.%-]+),%s*([%d%.%-]+),%s*([%d%.%-]+)")
				if x and y and z then
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(tonumber(x), tonumber(y), tonumber(z))
					
					WindUI:Notify({
						Title = "Teleported",
						Content = "Teleported to " .. XYZ,
						Duration = 3,
						Icon = "map-pin",
					})
				else
					WindUI:Notify({
						Title = "Error",
						Content = "Invalid coordinates format! Use: x, y, z",
						Duration = 3,
						Icon = "x",
					})
				end
			end
		})
	end



	
    local Player_Teleport = Teleport:Tab({
        Title = "Players Teleport",
        Icon = "lucide:move"
    })

--[[
    local Optional = Teleport:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })
]]
end

--[[-- World 
do
    local Visuals = World:Tab({
        Title = "Visuals",
        Icon = "lucide:cloud-sun"
    })

--[[
    local Optional = World:Tab({
        Title = "Optional",
        Icon = "lucide:list"
    })

end
--]]

-- Appearance & Configs 
do
    local Interface = AppearanceAndConfigs:Tab({
        Title = "Interface",
        Icon = "lucide:monitor"
    })
	
    local Theme = AppearanceAndConfigs:Tab({
        Title = "Theme",
        Icon = "lucide:droplet"
    })

    local Configuration = AppearanceAndConfigs:Tab({
        Title = "Configuration",
        Icon = "lucide:folder"
    })
end

-- Development
do
    local In_Dev = Development:Tab({
        Title = "In Dev",
        Icon = "lucide:wrench"
    })
	
    local Debug = Development:Tab({
        Title = "Debug",
        Icon = "lucide:activity"
    })


	do
		local Third_party_scripts = Development:Tab({
			Title = "Third-party scripts",
			Icon = "lucide:download"
		})

		local UNIVERSALSection = Third_party_scripts:Section({ Title = "UNIVERSAL", })
		
		local Load_DEX_BTN
		Load_DEX_BTN = Third_party_scripts:Button({
			Title = "Load DEX",
			Callback = function()
				Load_DEX_BTN:Highlight()
				loadstring(game:HttpGet("https://raw.githubusercontent.com/Y-ForBE-Y/ioasduq089eu3oi13u12o3u/refs/heads/main/My%20Script/XZCHEZAZALUPA/DEXPP.txt"))()
			end
		})

		local Load_INFYALD_BTN
		Load_INFYALD_BTN = Third_party_scripts:Button({
			Title = "Load INF YALD",
			Callback = function()
				Load_INFYALD_BTN:Highlight()
				loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
			end
		})
	end
end

print("Fully Loaded")





